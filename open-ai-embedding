from flask import Flask, request, jsonify
from flask_cors import CORS
from pydantic import BaseModel, ValidationError
from openai import OpenAI
import faiss
import numpy as np
import tiktoken
import uuid
import time
import threading
from typing import List, Optional
import os

app = Flask(__name__)
CORS(app)

client = OpenAI()   # Uses OPENAI_API_KEY automatically

SESSION_TIMEOUT = 1800  # 30 minutes
user_sessions = {}


# -----------------------------
#    INPUT MODELS
# -----------------------------
class TextInput(BaseModel):
    text: str
    user_id: Optional[str] = None

class QueryInput(BaseModel):
    query: str
    top_k: int = 5
    user_id: str

class DeleteSessionInput(BaseModel):
    user_id: str


# -----------------------------
#     CHUNKING FUNCTION
# -----------------------------
def chunk_text(text: str, chunk_size: int = 200, overlap: int = 50) -> List[str]:
    encoding = tiktoken.get_encoding("cl100k_base")
    tokens = encoding.encode(text)
    chunks = []

    i = 0
    while i < len(tokens):
        chunk_tokens = tokens[i : i + chunk_size]
        chunk_str = encoding.decode(chunk_tokens)
        chunks.append(chunk_str)
        i += chunk_size - overlap

    return chunks


# -----------------------------
#     OPENAI EMBEDDINGS
# -----------------------------
def embed_chunks(chunks: List[str]) -> np.ndarray:
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=chunks
    )
    vectors = [item.embedding for item in response.data]
    return np.array(vectors, dtype=np.float32)


def embed_query(query: str) -> np.ndarray:
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=[query]
    )
    return np.array(response.data[0].embedding, dtype=np.float32)


def update_last_access(user_id: str):
    if user_id in user_sessions:
        user_sessions[user_id]["last_accessed"] = time.time()


# -----------------------------
#       INITIALIZE STORE
# -----------------------------
@app.route('/initialize', methods=['POST'])
def build_vector_store():
    try:
        payload = TextInput(**request.json)
    except ValidationError as e:
        return jsonify({'error': e.errors()}), 400

    user_id = payload.user_id or str(uuid.uuid4())

    text_chunks = chunk_text(payload.text)
    if not text_chunks:
        return jsonify({"error": "No text chunks found after chunking."}), 400

    embeddings = embed_chunks(text_chunks)
    dim = embeddings.shape[1]

    index = faiss.IndexFlatL2(dim)
    index.add(embeddings)

    user_sessions[user_id] = {
        "index": index,
        "chunks": text_chunks,
        "last_accessed": time.time(),
    }

    return jsonify({
        "status": "success",
        "user_id": user_id,
        "chunks_stored": len(text_chunks)
    })


# -----------------------------
#          QUERY STORE
# -----------------------------
@app.route('/query_vector_store', methods=['POST'])
def query_vector_store():
    try:
        payload = QueryInput(**request.json)
    except ValidationError as e:
        return jsonify({'error': e.errors()}), 400

    user_id = payload.user_id
    if user_id not in user_sessions:
        return jsonify({"error": f"User session '{user_id}' not found."}), 404

    update_last_access(user_id)
    session = user_sessions[user_id]

    index = session["index"]
    text_chunks = session["chunks"]

    query_vec = embed_query(payload.query)
    D, I = index.search(np.array([query_vec]), payload.top_k)

    results = [text_chunks[idx] for idx in I[0] if idx < len(text_chunks)]

    return jsonify({"matches": results})


# -----------------------------
#         DELETE SESSION
# -----------------------------
@app.route('/delete_session', methods=['POST'])
def delete_session():
    try:
        payload = DeleteSessionInput(**request.json)
    except ValidationError as e:
        return jsonify({'error': e.errors()}), 400

    user_id = payload.user_id

    if user_id in user_sessions:
        del user_sessions[user_id]
        return jsonify({"status": "success", "message": f"Session '{user_id}' deleted."})

    return jsonify({"error": f"User session '{user_id}' not found."}), 404


# -----------------------------
#      BACKGROUND CLEANUP
# -----------------------------
def cleanup_sessions():
    while True:
        now = time.time()
        expired = [
            uid for uid, sess in user_sessions.items()
            if now - sess["last_accessed"] > SESSION_TIMEOUT
        ]

        for user_id in expired:
            del user_sessions[user_id]
            print(f"Session '{user_id}' expired & deleted.")

        time.sleep(600)  # check every 10 minutes


cleanup_thread = threading.Thread(target=cleanup_sessions, daemon=True)
cleanup_thread.start()


# -----------------------------
#     START SERVER
# -----------------------------
if __name__ == '__main__':
    port = int(os.environ.get("PORT", 5000))
    app.run(host='0.0.0.0', port=port)
